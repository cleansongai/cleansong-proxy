<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CleanSong Audio Processor</title>
  <style>
    body {
      background: none;
      min-height: 100vh;
      margin: 0;
      font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .container {
      background: none;
      border-radius: 18px;
      box-shadow: none;
      padding: 2.5rem 2rem 2rem 2rem;
      max-width: 420px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.2rem;
    }
    h1 {
      margin: 0 0 0.5rem 0;
      font-size: 2rem;
      color: #00ffff;
      letter-spacing: 1px;
      text-shadow: 0 0 8px #00ffff, 0 0 16px #00ffff;
    }
    .file-input {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      width: 100%;
    }
    input[type="file"] {
      padding: 0.5rem;
      border-radius: 8px;
      border: 1px solid #00ffff;
      background: #000;
      width: 100%;
      font-size: 1rem;
      color: #39FF14;
      box-shadow: 0 0 8px #00ffff;
    }
    input[type="file"]::file-selector-button {
      color: #00ffff;
      background: #000;
      border: 1px solid #00ffff;
      border-radius: 6px;
      padding: 0.3em 1em;
      cursor: pointer;
      text-shadow: 0 0 8px #00ffff;
    }
    button {
      background: linear-gradient(90deg, #6366f1 0%, #818cf8 100%);
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 0.7rem 2.2rem;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, box-shadow 0.2s;
      box-shadow: 0 2px 8px rgba(99,102,241,0.08);
    }
    button:hover {
      background: linear-gradient(90deg, #4f46e5 0%, #6366f1 100%);
    }
    #timer, #status {
      font-size: 1rem;
      color: #39FF14;
      margin-top: 0.2rem;
      min-height: 1.2em;
      text-align: center;
      text-shadow: 0 0 8px #39FF14;
    }
    #lyrics {
      margin-top: 1.2rem;
      background: #000;
      border-radius: 10px;
      padding: 1rem;
      width: 100%;
      box-sizing: border-box;
      color: #00ffff;
      font-size: 1.05rem;
      min-height: 3em;
      text-shadow: 0 0 8px #00ffff;
    }
    #lyrics h3 {
      margin: 0.5em 0 0.2em 0;
      color: #39FF14;
      font-size: 1.1em;
      text-shadow: 0 0 8px #39FF14;
    }
    audio {
      margin-top: 1.2rem;
      width: 100%;
      border-radius: 8px;
      background: #000;
      outline: none;
      box-shadow: 0 0 8px #00ffff;
    }
    @media (max-width: 500px) {
      .container {
        padding: 1.2rem 0.5rem 1.5rem 0.5rem;
        max-width: 98vw;
      }
      h1 {
        font-size: 1.3rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>CleanSong Audio Processor</h1>
    <div class="file-input">
      <input type="file" id="file" accept="audio/*">
      <button id="process">Process</button>
    </div>
    <div id="timer"></div>
    <div id="status"></div>
    <div id="lyrics"></div>
    <audio id="outAudio" controls></audio>
  </div>

<script>
const btn = document.getElementById("process");
const fileInput = document.getElementById("file");
const lyricsDiv = document.getElementById("lyrics");
const outAudio = document.getElementById("outAudio");
const timerDiv = document.getElementById("timer");
const statusDiv = document.getElementById("status");

// Function to compress audio using Web Audio API
async function compressAudio(file) {
  return new Promise((resolve, reject) => {
    const fileReader = new FileReader();
    
    fileReader.onload = async (e) => {
      try {
        const arrayBuffer = e.target.result;
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        console.log(`Original audio: ${audioBuffer.sampleRate}Hz, ${audioBuffer.numberOfChannels} channels, ${audioBuffer.duration.toFixed(2)}s`);
        
        // Very aggressive compression settings
        const targetSampleRate = 8000; // 8kHz sample rate
        const targetChannels = 1; // Mono
        const targetDuration = Math.min(audioBuffer.duration, 15); // Max 15 seconds for very small files
        
        const offlineContext = new OfflineAudioContext(
          targetChannels, 
          targetDuration * targetSampleRate, 
          targetSampleRate
        );
        
        const source = offlineContext.createBufferSource();
        source.buffer = audioBuffer;
        
        // Add a low-pass filter to reduce high frequencies
        const filter = offlineContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 3400; // Cut off above 3.4kHz
        
        // Add gain reduction
        const gainNode = offlineContext.createGain();
        gainNode.gain.value = 0.8; // Reduce volume slightly
        
        source.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(offlineContext.destination);
        
        const compressedBuffer = await offlineContext.startRendering();
        
        console.log(`Compressed audio: ${compressedBuffer.sampleRate}Hz, ${compressedBuffer.numberOfChannels} channels, ${compressedBuffer.duration.toFixed(2)}s`);
        
        // Convert back to WAV with 8-bit encoding for even smaller size
        const wavBuffer = audioBufferToWav8Bit(compressedBuffer);
        const blob = new Blob([wavBuffer], { type: 'audio/wav' });
        
        console.log(`Final blob size: ${(blob.size / (1024 * 1024)).toFixed(2)}MB`);
        resolve(blob);
      } catch (err) {
        console.error("Compression error:", err);
        reject(err);
      }
    };
    
    fileReader.readAsArrayBuffer(file);
  });
}

// Function to convert AudioBuffer to WAV
function audioBufferToWav(buffer) {
  const length = buffer.length;
  const arrayBuffer = new ArrayBuffer(44 + length * 2);
  const view = new DataView(arrayBuffer);
  
  // WAV header
  const writeString = (offset, string) => {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  };
  
  writeString(0, 'RIFF');
  view.setUint32(4, 36 + length * 2, true);
  writeString(8, 'WAVE');
  writeString(12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, 1, true);
  view.setUint32(24, 8000, true);
  view.setUint32(28, 16000, true);
  view.setUint16(32, 2, true);
  view.setUint16(34, 16, true);
  writeString(36, 'data');
  view.setUint32(40, length * 2, true);
  
  // Convert float samples to 16-bit PCM
  const channelData = buffer.getChannelData(0);
  let offset = 44;
  for (let i = 0; i < length; i++) {
    const sample = Math.max(-1, Math.min(1, channelData[i]));
    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
    offset += 2;
  }
  
  return arrayBuffer;
}

// Function to convert AudioBuffer to 8-bit WAV (much smaller)
function audioBufferToWav8Bit(buffer) {
  const length = buffer.length;
  const arrayBuffer = new ArrayBuffer(44 + length); // 8-bit = 1 byte per sample
  const view = new DataView(arrayBuffer);
  
  // WAV header for 8-bit
  const writeString = (offset, string) => {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  };
  
  writeString(0, 'RIFF');
  view.setUint32(4, 36 + length, true);
  writeString(8, 'WAVE');
  writeString(12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true); // PCM
  view.setUint16(22, 1, true); // Mono
  view.setUint32(24, 8000, true); // 8kHz
  view.setUint32(28, 8000, true); // Byte rate
  view.setUint16(32, 1, true); // Block align
  view.setUint16(34, 8, true); // 8 bits per sample
  writeString(36, 'data');
  view.setUint32(40, length, true);
  
  // Convert float samples to 8-bit PCM (0-255)
  const channelData = buffer.getChannelData(0);
  let offset = 44;
  for (let i = 0; i < length; i++) {
    const sample = Math.max(-1, Math.min(1, channelData[i]));
    const sample8bit = Math.round((sample + 1) * 127.5); // Convert -1..1 to 0..255
    view.setUint8(offset, sample8bit);
    offset++;
  }
  
  return arrayBuffer;
}

btn.onclick = async () => {
  const file = fileInput.files[0];
  if (!file) return alert("Choose a file!");
  if (file.size > 4 * 1024 * 1024) {
    alert("File is too large! Please select a file smaller than 4MB.");
    return;
  }

  let timer = 0;
  timerDiv.textContent = "Processing time: 0s";
  statusDiv.textContent = "";
  let interval = setInterval(() => {
    timer++;
    timerDiv.textContent = `Processing time: ${timer}s`;
  }, 1000);

  // Compress audio if it's large
  let processedFile = file;
  console.log(`Original file size: ${(file.size / (1024 * 1024)).toFixed(2)}MB`);
  
  // Compress if larger than 1MB (more aggressive threshold)
  if (file.size > 1 * 1024 * 1024) { // 1MB
    statusDiv.textContent = "Compressing audio...";
    try {
      processedFile = await compressAudio(file);
      console.log(`Compressed from ${(file.size / (1024 * 1024)).toFixed(2)}MB to ${(processedFile.size / (1024 * 1024)).toFixed(2)}MB`);
      statusDiv.textContent = `Compressed to ${(processedFile.size / (1024 * 1024)).toFixed(2)}MB`;
      
      // If still too large, try even more aggressive compression
      if (processedFile.size > 1.5 * 1024 * 1024) {
        statusDiv.textContent = "Further compressing audio...";
        processedFile = await compressAudio(processedFile);
        console.log(`Further compressed to ${(processedFile.size / (1024 * 1024)).toFixed(2)}MB`);
        statusDiv.textContent = `Final size: ${(processedFile.size / (1024 * 1024)).toFixed(2)}MB`;
      }
      
      // If still too large, try one more time with even more aggressive settings
      if (processedFile.size > 1.5 * 1024 * 1024) {
        statusDiv.textContent = "Final compression attempt...";
        processedFile = await compressAudio(processedFile);
        console.log(`Final compression: ${(processedFile.size / (1024 * 1024)).toFixed(2)}MB`);
        statusDiv.textContent = `Final size: ${(processedFile.size / (1024 * 1024)).toFixed(2)}MB`;
      }
    } catch (err) {
      console.error("Compression failed:", err);
      statusDiv.textContent = "Compression failed, using original file...";
    }
  } else {
    console.log("File is small enough, no compression needed");
  }

  // Check if file is still too large after compression
  if (processedFile.size > 2 * 1024 * 1024) {
    clearInterval(interval);
    timerDiv.textContent = "";
    statusDiv.textContent = "";
    lyricsDiv.innerHTML = `<span style="color:#ff6b6b">Error: File is still too large (${(processedFile.size / (1024 * 1024)).toFixed(2)}MB) after compression. Please try a shorter audio file.</span>`;
    return;
  }

  const reader = new FileReader();
  reader.onloadend = async () => {
    const base64 = reader.result;
    try {
      statusDiv.textContent = "Calling Hugging Face API...";
      const res = await fetch("/api/process", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ file: base64 })
      });
      
      // Check if response is JSON
      const contentType = res.headers.get("content-type");
      if (!contentType || !contentType.includes("application/json")) {
        const text = await res.text();
        throw new Error(`Server returned non-JSON response: ${text.substring(0, 200)}...`);
      }
      
      const json = await res.json();
      clearInterval(interval);
      timerDiv.textContent = `Total processing time: ${timer}s`;
      statusDiv.textContent = "Processing complete.";
      console.log(json);
      if (!res.ok) {
        lyricsDiv.innerHTML = `<span style=\"color:#39FF14\">Error: ${json.error || "Unknown error"}</span>`;
        return;
      }
      lyricsDiv.innerHTML = `
        <h3>Original Lyrics</h3><p>${json.original}</p>
        <h3>Cleaned Lyrics</h3><p>${json.cleaned}</p>
      `;
      if (json.audio?.url) {
        outAudio.src = json.audio.url;
        outAudio.load();
      }
    } catch (err) {
      clearInterval(interval);
      timerDiv.textContent = "";
      statusDiv.textContent = "";
      let errorMessage = err.message;
      
      // Provide more helpful error messages
      if (err.message === "Failed to fetch") {
        errorMessage = "Cannot connect to server. Make sure the development server is running on http://localhost:3000";
      } else if (err.message.includes("CORS")) {
        errorMessage = "CORS error. Make sure you're accessing the app through the development server.";
      }
      
      lyricsDiv.innerHTML = `<span style=\"color:#ff6b6b\">Error: ${errorMessage}</span>`;
      console.error(err);
    }
  };
  reader.readAsDataURL(processedFile);
};
</script>
</body>
</html>
